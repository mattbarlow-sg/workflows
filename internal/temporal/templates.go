// Package temporal provides Temporal workflow infrastructure
package temporal

// Template definitions for workflow generation

const basicWorkflowTemplate = `// Code generated by Temporal Workflow Generator at {{.Timestamp}}
// DO NOT EDIT MANUALLY

package {{.Package}}

import (
{{range .Imports}}	"{{.}}"
{{end}}
)

// {{.WorkflowName}}Workflow implements {{.Description}}
type {{.WorkflowName}}Workflow struct {
	// Workflow state
}

// {{.WorkflowName}}Input defines the workflow input
type {{.WorkflowName}}Input struct {
	{{.InputType}}
}

// {{.WorkflowName}}Output defines the workflow output
type {{.WorkflowName}}Output struct {
	{{.OutputType}}
}

// Execute runs the {{.WorkflowName}} workflow
func (w *{{.WorkflowName}}Workflow) Execute(ctx workflow.Context, input {{.WorkflowName}}Input) ({{.WorkflowName}}Output, error) {
	logger := workflow.GetLogger(ctx)
	logger.Info("Starting {{.WorkflowName}} workflow", "input", input)

	var output {{.WorkflowName}}Output

	// Workflow configuration
	ao := workflow.ActivityOptions{
		StartToCloseTimeout: 10 * time.Minute,
		RetryPolicy: &temporal.RetryPolicy{
			InitialInterval:    time.Second,
			BackoffCoefficient: 2.0,
			MaximumInterval:    100 * time.Second,
			MaximumAttempts:    3,
		},
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	{{range .Activities}}
	// Execute {{.Name}} activity
	var {{.Name}}Result {{.OutputType}}
	err := workflow.ExecuteActivity(ctx, {{.Name}}Activity, input).Get(ctx, &{{.Name}}Result)
	if err != nil {
		logger.Error("{{.Name}} activity failed", "error", err)
		return output, err
	}
	{{end}}

	{{range .Signals}}
	// Setup signal handler for {{.Name}}
	signalChan := workflow.GetSignalChannel(ctx, "{{.Name}}")
	workflow.Go(ctx, func(ctx workflow.Context) {
		var signal {{.PayloadType}}
		signalChan.Receive(ctx, &signal)
		logger.Info("Received {{.Name}} signal", "signal", signal)
	})
	{{end}}

	{{range .Queries}}
	// Setup query handler for {{.Name}}
	err := workflow.SetQueryHandler(ctx, "{{.Name}}", func() ({{.ResponseType}}, error) {
		return output, nil
	})
	if err != nil {
		logger.Error("Failed to set query handler for {{.Name}}", "error", err)
	}
	{{end}}

	{{range .ChildWorkflows}}
	// Execute child workflow {{.Name}}
	childCtx := workflow.WithChildOptions(ctx, workflow.ChildWorkflowOptions{
		WorkflowID:  fmt.Sprintf("%s-child-%s", workflow.GetInfo(ctx).WorkflowExecution.ID, "{{.Name}}"),
		TaskQueue:   "{{.TaskQueue}}",
	})

	var childResult {{.OutputType}}
	future := workflow.ExecuteChildWorkflow(childCtx, "{{.Name}}Workflow", {{.InputType}}{})
	if err := future.Get(childCtx, &childResult); err != nil {
		logger.Error("Child workflow failed", "workflow", "{{.Name}}", "error", err)
		return output, err
	}
	{{end}}

	logger.Info("Completed {{.WorkflowName}} workflow", "output", output)
	return output, nil
}

// Register{{.WorkflowName}} registers the workflow with a worker
func Register{{.WorkflowName}}(w worker.Worker) {
	w.RegisterWorkflow({{.WorkflowName}}Workflow{}.Execute)
	{{range .Activities}}
	w.RegisterActivity({{.Name}}Activity)
	{{end}}
}
`

const approvalWorkflowTemplate = `// Code generated by Temporal Workflow Generator at {{.Timestamp}}
// DO NOT EDIT MANUALLY

package {{.Package}}

import (
{{range .Imports}}	"{{.}}"
{{end}}
)

// {{.WorkflowName}}Workflow implements an approval workflow with human tasks
type {{.WorkflowName}}Workflow struct {
	approvals []ApprovalRecord
	status    ApprovalStatus
}

// ApprovalRecord tracks an approval decision
type ApprovalRecord struct {
	Approver  string
	Decision  string
	Timestamp time.Time
	Comments  string
}

// ApprovalStatus represents the workflow approval status
type ApprovalStatus string

const (
	ApprovalStatusPending   ApprovalStatus = "pending"
	ApprovalStatusApproved  ApprovalStatus = "approved"
	ApprovalStatusRejected  ApprovalStatus = "rejected"
	ApprovalStatusEscalated ApprovalStatus = "escalated"
)

// {{.WorkflowName}}Input defines the approval request
type {{.WorkflowName}}Input struct {
	RequestID    string
	RequestType  string
	Requester    string
	Approvers    []string
	EscalationTo string
	Timeout      time.Duration
	{{.InputType}}
}

// {{.WorkflowName}}Output defines the approval result
type {{.WorkflowName}}Output struct {
	RequestID string
	Status    ApprovalStatus
	Approvals []ApprovalRecord
	{{.OutputType}}
}

// Execute runs the approval workflow
func (w *{{.WorkflowName}}Workflow) Execute(ctx workflow.Context, input {{.WorkflowName}}Input) ({{.WorkflowName}}Output, error) {
	logger := workflow.GetLogger(ctx)
	logger.Info("Starting approval workflow", "requestID", input.RequestID)

	w.status = ApprovalStatusPending
	output := {{.WorkflowName}}Output{
		RequestID: input.RequestID,
		Status:    w.status,
	}

	// Set up approval signal channel
	approvalChan := workflow.GetSignalChannel(ctx, "approval")
	
	// Set up query handler for status
	workflow.SetQueryHandler(ctx, "status", func() (ApprovalStatus, error) {
		return w.status, nil
	})

	// Process approvals
	for _, approver := range input.Approvers {
		logger.Info("Waiting for approval", "approver", approver)
		
		// Create human task
		taskID := fmt.Sprintf("approval-%s-%s", input.RequestID, approver)
		err := workflow.ExecuteActivity(ctx, CreateHumanTaskActivity, CreateHumanTaskInput{
			TaskID:      taskID,
			AssignedTo:  approver,
			Description: fmt.Sprintf("Approve request %s", input.RequestID),
			Deadline:    input.Timeout,
		}).Get(ctx, nil)
		if err != nil {
			logger.Error("Failed to create human task", "error", err)
			return output, err
		}

		// Wait for approval with timeout
		selector := workflow.NewSelector(ctx)
		
		timerCtx, cancel := workflow.WithCancel(ctx)
		timer := workflow.NewTimer(timerCtx, input.Timeout)
		
		var approval ApprovalRecord
		selector.AddReceive(approvalChan, func(c workflow.ReceiveChannel, more bool) {
			c.Receive(ctx, &approval)
			w.approvals = append(w.approvals, approval)
			if approval.Decision == "approved" {
				w.status = ApprovalStatusApproved
			} else {
				w.status = ApprovalStatusRejected
			}
			cancel() // Cancel timer
		})
		
		selector.AddFuture(timer, func(f workflow.Future) {
			// Timeout - escalate
			logger.Warn("Approval timeout, escalating", "approver", approver)
			w.status = ApprovalStatusEscalated
			
			// Escalate to next level
			workflow.ExecuteActivity(ctx, EscalateTaskActivity, EscalateTaskInput{
				TaskID:     taskID,
				EscalateTo: input.EscalationTo,
			}).Get(ctx, nil)
		})
		
		selector.Select(ctx)
		
		// Check if rejected
		if w.status == ApprovalStatusRejected {
			logger.Info("Request rejected", "approver", approver)
			break
		}
	}

	output.Status = w.status
	output.Approvals = w.approvals
	
	logger.Info("Approval workflow completed", "status", w.status)
	return output, nil
}

// CreateHumanTaskActivity creates a human task
func CreateHumanTaskActivity(ctx context.Context, input CreateHumanTaskInput) error {
	// Implementation would create task in external system
	return nil
}

// EscalateTaskActivity escalates a task
func EscalateTaskActivity(ctx context.Context, input EscalateTaskInput) error {
	// Implementation would escalate task in external system
	return nil
}

// CreateHumanTaskInput defines input for creating a human task
type CreateHumanTaskInput struct {
	TaskID      string
	AssignedTo  string
	Description string
	Deadline    time.Duration
}

// EscalateTaskInput defines input for escalating a task
type EscalateTaskInput struct {
	TaskID     string
	EscalateTo string
}
`

const scheduledWorkflowTemplate = `// Code generated by Temporal Workflow Generator at {{.Timestamp}}
// DO NOT EDIT MANUALLY

package {{.Package}}

import (
{{range .Imports}}	"{{.}}"
{{end}}
	"go.temporal.io/sdk/temporal"
)

// {{.WorkflowName}}Workflow implements a scheduled/cron workflow
type {{.WorkflowName}}Workflow struct {
	executionCount int
	lastExecutionTime time.Time
}

// {{.WorkflowName}}Input defines the scheduled workflow input
type {{.WorkflowName}}Input struct {
	Schedule   string // Cron expression
	MaxRuns    int
	{{.InputType}}
}

// {{.WorkflowName}}Output defines the scheduled workflow output
type {{.WorkflowName}}Output struct {
	ExecutionCount int
	LastExecution  time.Time
	{{.OutputType}}
}

// Execute runs the scheduled workflow
func (w *{{.WorkflowName}}Workflow) Execute(ctx workflow.Context, input {{.WorkflowName}}Input) ({{.WorkflowName}}Output, error) {
	logger := workflow.GetLogger(ctx)
	logger.Info("Starting scheduled workflow", "schedule", input.Schedule)

	output := {{.WorkflowName}}Output{}
	
	// Configure activity options
	ao := workflow.ActivityOptions{
		StartToCloseTimeout: 10 * time.Minute,
		RetryPolicy: &temporal.RetryPolicy{
			InitialInterval:    time.Second,
			BackoffCoefficient: 2.0,
			MaximumInterval:    100 * time.Second,
			MaximumAttempts:    3,
		},
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// Set up query handler for status
	workflow.SetQueryHandler(ctx, "status", func() ({{.WorkflowName}}Output, error) {
		return output, nil
	})

	// Execute scheduled activities
	for w.executionCount < input.MaxRuns || input.MaxRuns == 0 {
		w.executionCount++
		w.lastExecutionTime = workflow.Now(ctx)
		
		logger.Info("Executing scheduled task", "count", w.executionCount)
		
		{{range .Activities}}
		// Execute {{.Name}} activity
		var {{.Name}}Result {{.OutputType}}
		err := workflow.ExecuteActivity(ctx, {{.Name}}Activity, input).Get(ctx, &{{.Name}}Result)
		if err != nil {
			logger.Error("{{.Name}} activity failed", "error", err)
			// Continue with next execution
		}
		{{end}}
		
		// Update output
		output.ExecutionCount = w.executionCount
		output.LastExecution = w.lastExecutionTime
		
		// Wait for next scheduled time
		if w.executionCount < input.MaxRuns || input.MaxRuns == 0 {
			// Calculate next execution time based on cron schedule
			nextTime := calculateNextCronTime(input.Schedule, w.lastExecutionTime)
			sleepDuration := nextTime.Sub(w.lastExecutionTime)
			
			logger.Info("Sleeping until next execution", "duration", sleepDuration)
			workflow.Sleep(ctx, sleepDuration)
		}
	}

	logger.Info("Scheduled workflow completed", "totalExecutions", w.executionCount)
	return output, nil
}

// calculateNextCronTime calculates the next execution time based on cron expression
func calculateNextCronTime(cronExpr string, currentTime time.Time) time.Time {
	// This would use a cron parser library in real implementation
	// For now, return next hour
	return currentTime.Add(time.Hour)
}
`

const humanTaskWorkflowTemplate = `// Code generated by Temporal Workflow Generator at {{.Timestamp}}
// DO NOT EDIT MANUALLY

package {{.Package}}

import (
{{range .Imports}}	"{{.}}"
{{end}}
)

// {{.WorkflowName}}Workflow implements a human task workflow
type {{.WorkflowName}}Workflow struct {
	tasks      []HumanTask
	completed  []CompletedTask
}

// HumanTask represents a task assigned to a human
type HumanTask struct {
	ID          string
	AssignedTo  string
	Description string
	Priority    Priority
	Deadline    time.Time
	Status      TaskStatus
	CreatedAt   time.Time
}

// CompletedTask represents a completed human task
type CompletedTask struct {
	Task       HumanTask
	CompletedBy string
	CompletedAt time.Time
	Result      interface{}
}

// Priority defines task priority levels
type Priority string

const (
	PriorityLow    Priority = "low"
	PriorityMedium Priority = "medium"
	PriorityHigh   Priority = "high"
	PriorityCritical Priority = "critical"
)

// TaskStatus defines task status
type TaskStatus string

const (
	TaskStatusPending   TaskStatus = "pending"
	TaskStatusAssigned  TaskStatus = "assigned"
	TaskStatusInProgress TaskStatus = "in_progress"
	TaskStatusCompleted TaskStatus = "completed"
	TaskStatusEscalated TaskStatus = "escalated"
)

// {{.WorkflowName}}Input defines the human task workflow input
type {{.WorkflowName}}Input struct {
	{{.InputType}}
}

// {{.WorkflowName}}Output defines the human task workflow output
type {{.WorkflowName}}Output struct {
	CompletedTasks []CompletedTask
	{{.OutputType}}
}

// Execute runs the human task workflow
func (w *{{.WorkflowName}}Workflow) Execute(ctx workflow.Context, input {{.WorkflowName}}Input) ({{.WorkflowName}}Output, error) {
	logger := workflow.GetLogger(ctx)
	logger.Info("Starting human task workflow")

	output := {{.WorkflowName}}Output{}

	// Configure activity options
	ao := workflow.ActivityOptions{
		StartToCloseTimeout: 24 * time.Hour, // Long timeout for human tasks
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// Set up signal channels
	taskCompleteChan := workflow.GetSignalChannel(ctx, "taskComplete")
	taskReassignChan := workflow.GetSignalChannel(ctx, "taskReassign")
	
	// Set up query handlers
	workflow.SetQueryHandler(ctx, "getTasks", func() ([]HumanTask, error) {
		return w.tasks, nil
	})
	
	workflow.SetQueryHandler(ctx, "getCompletedTasks", func() ([]CompletedTask, error) {
		return w.completed, nil
	})

	{{range .HumanTasks}}
	// Create {{.Name}} human task
	task := HumanTask{
		ID:          "{{.Name}}-" + workflow.GetInfo(ctx).WorkflowExecution.ID,
		AssignedTo:  "{{.AssignedTo}}",
		Description: "{{.Description}}",
		Priority:    Priority("{{.Priority}}"),
		Deadline:    workflow.Now(ctx).Add(time.Duration({{.Deadline.Nanoseconds}})),
		Status:      TaskStatusPending,
		CreatedAt:   workflow.Now(ctx),
	}
	w.tasks = append(w.tasks, task)

	// Create task in external system
	err := workflow.ExecuteActivity(ctx, CreateTaskActivity, task).Get(ctx, nil)
	if err != nil {
		logger.Error("Failed to create task", "taskID", task.ID, "error", err)
		return output, err
	}

	// Wait for task completion or timeout
	selector := workflow.NewSelector(ctx)
	
	// Completion handler
	selector.AddReceive(taskCompleteChan, func(c workflow.ReceiveChannel, more bool) {
		var completion TaskCompletion
		c.Receive(ctx, &completion)
		
		if completion.TaskID == task.ID {
			completedTask := CompletedTask{
				Task:        task,
				CompletedBy: completion.CompletedBy,
				CompletedAt: workflow.Now(ctx),
				Result:      completion.Result,
			}
			w.completed = append(w.completed, completedTask)
			task.Status = TaskStatusCompleted
			logger.Info("Task completed", "taskID", task.ID)
		}
	})
	
	// Reassignment handler
	selector.AddReceive(taskReassignChan, func(c workflow.ReceiveChannel, more bool) {
		var reassignment TaskReassignment
		c.Receive(ctx, &reassignment)
		
		if reassignment.TaskID == task.ID {
			task.AssignedTo = reassignment.NewAssignee
			task.Status = TaskStatusAssigned
			logger.Info("Task reassigned", "taskID", task.ID, "newAssignee", reassignment.NewAssignee)
			
			// Update task in external system
			workflow.ExecuteActivity(ctx, UpdateTaskActivity, task).Get(ctx, nil)
		}
	})
	
	// Timeout handler with escalation
	timerCtx, cancel := workflow.WithCancel(ctx)
	timer := workflow.NewTimer(timerCtx, time.Duration({{.EscalationTime.Nanoseconds}}))
	
	selector.AddFuture(timer, func(f workflow.Future) {
		logger.Warn("Task timeout, escalating", "taskID", task.ID)
		task.Status = TaskStatusEscalated
		
		// Escalate task
		workflow.ExecuteActivity(ctx, EscalateTaskActivity, EscalationInput{
			TaskID:     task.ID,
			EscalateTo: "{{.EscalationTo}}",
			Reason:     "Timeout",
		}).Get(ctx, nil)
	})
	
	selector.Select(ctx)
	cancel() // Cancel timer if task completed
	{{end}}

	output.CompletedTasks = w.completed
	logger.Info("Human task workflow completed", "completedTasks", len(w.completed))
	return output, nil
}

// TaskCompletion represents a task completion signal
type TaskCompletion struct {
	TaskID      string
	CompletedBy string
	Result      interface{}
}

// TaskReassignment represents a task reassignment signal
type TaskReassignment struct {
	TaskID      string
	NewAssignee string
	Reason      string
}

// EscalationInput defines escalation parameters
type EscalationInput struct {
	TaskID     string
	EscalateTo string
	Reason     string
}

// Task management activities would be implemented here
func CreateTaskActivity(ctx context.Context, task HumanTask) error {
	// Implementation would create task in external system
	return nil
}

func UpdateTaskActivity(ctx context.Context, task HumanTask) error {
	// Implementation would update task in external system
	return nil
}

func EscalateTaskActivity(ctx context.Context, input EscalationInput) error {
	// Implementation would escalate task
	return nil
}
`

const longRunningWorkflowTemplate = `// Code generated by Temporal Workflow Generator at {{.Timestamp}}
// DO NOT EDIT MANUALLY

package {{.Package}}

import (
{{range .Imports}}	"{{.}}"
{{end}}
)

// {{.WorkflowName}}Workflow implements a long-running workflow with checkpoints
type {{.WorkflowName}}Workflow struct {
	state      WorkflowState
	checkpoints []Checkpoint
	startTime  time.Time
}

// WorkflowState represents the current state of the long-running workflow
type WorkflowState struct {
	Phase           string
	Progress        int
	LastCheckpoint  time.Time
	Data            map[string]interface{}
}

// Checkpoint represents a workflow checkpoint
type Checkpoint struct {
	ID        string
	Phase     string
	Timestamp time.Time
	Data      interface{}
}

// {{.WorkflowName}}Input defines the long-running workflow input
type {{.WorkflowName}}Input struct {
	MaxDuration time.Duration
	{{.InputType}}
}

// {{.WorkflowName}}Output defines the long-running workflow output
type {{.WorkflowName}}Output struct {
	TotalDuration time.Duration
	Checkpoints   []Checkpoint
	FinalState    WorkflowState
	{{.OutputType}}
}

// Execute runs the long-running workflow
func (w *{{.WorkflowName}}Workflow) Execute(ctx workflow.Context, input {{.WorkflowName}}Input) ({{.WorkflowName}}Output, error) {
	logger := workflow.GetLogger(ctx)
	logger.Info("Starting long-running workflow", "maxDuration", input.MaxDuration)

	w.startTime = workflow.Now(ctx)
	w.state = WorkflowState{
		Phase:    "initialization",
		Progress: 0,
		Data:     make(map[string]interface{}),
	}

	output := {{.WorkflowName}}Output{}

	// Configure activity options for long-running activities
	ao := workflow.ActivityOptions{
		StartToCloseTimeout: 1 * time.Hour,
		HeartbeatTimeout:    30 * time.Second, // Important for long-running activities
		RetryPolicy: &temporal.RetryPolicy{
			InitialInterval:    30 * time.Second,
			BackoffCoefficient: 2.0,
			MaximumInterval:    10 * time.Minute,
			MaximumAttempts:    5,
		},
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// Set up signal channels for control
	pauseChan := workflow.GetSignalChannel(ctx, "pause")
	resumeChan := workflow.GetSignalChannel(ctx, "resume")
	cancelChan := workflow.GetSignalChannel(ctx, "cancel")
	
	// Set up query handlers
	workflow.SetQueryHandler(ctx, "getState", func() (WorkflowState, error) {
		return w.state, nil
	})
	
	workflow.SetQueryHandler(ctx, "getProgress", func() (int, error) {
		return w.state.Progress, nil
	})

	// Main workflow logic with phases
	phases := []string{"initialization", "processing", "validation", "finalization"}
	
	for i, phase := range phases {
		w.state.Phase = phase
		w.state.Progress = (i * 100) / len(phases)
		
		logger.Info("Entering phase", "phase", phase, "progress", w.state.Progress)
		
		// Create checkpoint
		checkpoint := Checkpoint{
			ID:        fmt.Sprintf("checkpoint-%d", i),
			Phase:     phase,
			Timestamp: workflow.Now(ctx),
			Data:      w.state.Data,
		}
		w.checkpoints = append(w.checkpoints, checkpoint)
		w.state.LastCheckpoint = checkpoint.Timestamp
		
		// Check for pause signal
		var paused bool
		pauseChan.ReceiveAsync(&paused)
		if paused {
			logger.Info("Workflow paused", "phase", phase)
			
			// Wait for resume signal
			var resumed bool
			resumeChan.Receive(ctx, &resumed)
			logger.Info("Workflow resumed", "phase", phase)
		}
		
		// Check for cancel signal
		var cancelled bool
		cancelChan.ReceiveAsync(&cancelled)
		if cancelled {
			logger.Info("Workflow cancelled", "phase", phase)
			return output, workflow.NewContinueAsNewError(ctx, w.Execute, input)
		}
		
		// Execute phase-specific activities
		switch phase {
		case "initialization":
			err := w.executeInitialization(ctx, input)
			if err != nil {
				return output, err
			}
			
		case "processing":
			err := w.executeProcessing(ctx, input)
			if err != nil {
				return output, err
			}
			
		case "validation":
			err := w.executeValidation(ctx, input)
			if err != nil {
				return output, err
			}
			
		case "finalization":
			err := w.executeFinalization(ctx, input)
			if err != nil {
				return output, err
			}
		}
		
		// Sleep between phases (simulate long-running work)
		workflow.Sleep(ctx, 10*time.Minute)
		
		// Check if we've exceeded max duration
		elapsed := workflow.Now(ctx).Sub(w.startTime)
		if input.MaxDuration > 0 && elapsed > input.MaxDuration {
			logger.Warn("Max duration exceeded", "elapsed", elapsed)
			break
		}
	}

	// Prepare output
	output.TotalDuration = workflow.Now(ctx).Sub(w.startTime)
	output.Checkpoints = w.checkpoints
	output.FinalState = w.state
	
	logger.Info("Long-running workflow completed", "duration", output.TotalDuration)
	return output, nil
}

func (w *{{.WorkflowName}}Workflow) executeInitialization(ctx workflow.Context, input {{.WorkflowName}}Input) error {
	logger := workflow.GetLogger(ctx)
	logger.Info("Executing initialization phase")
	
	{{range .Activities}}
	{{if eq .Name "Initialize"}}
	var result {{.OutputType}}
	err := workflow.ExecuteActivity(ctx, {{.Name}}Activity, input).Get(ctx, &result)
	if err != nil {
		return err
	}
	w.state.Data["initialized"] = true
	{{end}}
	{{end}}
	
	return nil
}

func (w *{{.WorkflowName}}Workflow) executeProcessing(ctx workflow.Context, input {{.WorkflowName}}Input) error {
	logger := workflow.GetLogger(ctx)
	logger.Info("Executing processing phase")
	
	// Implement processing logic
	return nil
}

func (w *{{.WorkflowName}}Workflow) executeValidation(ctx workflow.Context, input {{.WorkflowName}}Input) error {
	logger := workflow.GetLogger(ctx)
	logger.Info("Executing validation phase")
	
	// Implement validation logic
	return nil
}

func (w *{{.WorkflowName}}Workflow) executeFinalization(ctx workflow.Context, input {{.WorkflowName}}Input) error {
	logger := workflow.GetLogger(ctx)
	logger.Info("Executing finalization phase")
	
	// Implement finalization logic
	return nil
}
`

const activityTemplate = `// Code generated by Temporal Workflow Generator at {{.Timestamp}}
// DO NOT EDIT MANUALLY

package {{.Package}}

import (
	"context"
	"fmt"
	"time"
)

{{range .Activities}}
// {{.Name}}Activity implements {{.Description}}
func {{.Name}}Activity(ctx context.Context, input {{.InputType}}) ({{.OutputType}}, error) {
	// TODO: Implement activity logic
	var result {{.OutputType}}
	
	{{if .IsHumanTask}}
	// This is a human task - implement task creation/management
	// Example: Create task in external system, wait for completion
	{{end}}
	
	return result, nil
}
{{end}}
`

const testTemplate = `// Code generated by Temporal Workflow Generator at {{.Timestamp}}
// DO NOT EDIT MANUALLY

package {{.Package}}_test

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/suite"
	"go.temporal.io/sdk/testsuite"
	"go.temporal.io/sdk/worker"
	
	"{{.Package}}"
)

type {{.WorkflowName}}TestSuite struct {
	suite.Suite
	testsuite.WorkflowTestSuite
	env *testsuite.TestWorkflowEnvironment
}

func (s *{{.WorkflowName}}TestSuite) SetupTest() {
	s.env = s.NewTestWorkflowEnvironment()
	
	// Register workflow and activities
	s.env.RegisterWorkflow({{.Package}}.{{.WorkflowName}}Workflow{}.Execute)
	{{range .Activities}}
	s.env.RegisterActivity({{$.Package}}.{{.Name}}Activity)
	{{end}}
}

func (s *{{.WorkflowName}}TestSuite) AfterTest(suiteName, testName string) {
	s.env.AssertExpectations(s.T())
}

func (s *{{.WorkflowName}}TestSuite) Test{{.WorkflowName}}Success() {
	// Arrange
	input := {{.Package}}.{{.WorkflowName}}Input{
		// TODO: Set input values
	}
	
	{{range .Activities}}
	// Mock {{.Name}} activity
	s.env.OnActivity({{$.Package}}.{{.Name}}Activity, mock.Anything, mock.Anything).Return(
		{{.OutputType}}{}, nil,
	)
	{{end}}
	
	// Act
	s.env.ExecuteWorkflow({{.Package}}.{{.WorkflowName}}Workflow{}.Execute, input)
	
	// Assert
	s.True(s.env.IsWorkflowCompleted())
	s.NoError(s.env.GetWorkflowError())
	
	var output {{.Package}}.{{.WorkflowName}}Output
	s.NoError(s.env.GetWorkflowResult(&output))
	// TODO: Add assertions on output
}

func (s *{{.WorkflowName}}TestSuite) Test{{.WorkflowName}}ActivityFailure() {
	// Test activity failure scenarios
	input := {{.Package}}.{{.WorkflowName}}Input{
		// TODO: Set input values
	}
	
	{{range .Activities}}
	// Mock {{.Name}} activity to fail
	s.env.OnActivity({{$.Package}}.{{.Name}}Activity, mock.Anything, mock.Anything).Return(
		{{.OutputType}}{}, fmt.Errorf("activity failed"),
	).Once()
	{{end}}
	
	// Act
	s.env.ExecuteWorkflow({{.Package}}.{{.WorkflowName}}Workflow{}.Execute, input)
	
	// Assert
	s.True(s.env.IsWorkflowCompleted())
	s.Error(s.env.GetWorkflowError())
}

{{range .Signals}}
func (s *{{$.WorkflowName}}TestSuite) Test{{$.WorkflowName}}{{.Name}}Signal() {
	// Test signal handling
	input := {{$.Package}}.{{$.WorkflowName}}Input{
		// TODO: Set input values
	}
	
	// Start workflow
	s.env.RegisterDelayedCallback(func() {
		// Send signal after workflow starts
		s.env.SignalWorkflow("{{.Name}}", {{.PayloadType}}{
			// TODO: Set signal payload
		})
	}, 100*time.Millisecond)
	
	s.env.ExecuteWorkflow({{$.Package}}.{{$.WorkflowName}}Workflow{}.Execute, input)
	
	// Assert signal was handled
	s.True(s.env.IsWorkflowCompleted())
	s.NoError(s.env.GetWorkflowError())
}
{{end}}

{{range .Queries}}
func (s *{{$.WorkflowName}}TestSuite) Test{{$.WorkflowName}}{{.Name}}Query() {
	// Test query handling
	input := {{$.Package}}.{{$.WorkflowName}}Input{
		// TODO: Set input values
	}
	
	s.env.RegisterDelayedCallback(func() {
		// Query workflow state
		result, err := s.env.QueryWorkflow("{{.Name}}")
		s.NoError(err)
		
		var response {{.ResponseType}}
		s.NoError(result.Get(&response))
		// TODO: Add assertions on response
	}, 100*time.Millisecond)
	
	s.env.ExecuteWorkflow({{$.Package}}.{{$.WorkflowName}}Workflow{}.Execute, input)
	
	s.True(s.env.IsWorkflowCompleted())
}
{{end}}

func Test{{.WorkflowName}}Suite(t *testing.T) {
	suite.Run(t, new({{.WorkflowName}}TestSuite))
}
`

const signalHandlerTemplate = `
// Signal handler for {{.Name}}
signalChan := workflow.GetSignalChannel(ctx, "{{.Name}}")
workflow.Go(ctx, func(ctx workflow.Context) {
	for {
		var signal {{.PayloadType}}
		if more := signalChan.Receive(ctx, &signal); !more {
			return
		}
		logger.Info("Received {{.Name}} signal", "payload", signal)
		// Handle signal
		{{.Description}}
	}
})
`

const queryHandlerTemplate = `
// Query handler for {{.Name}}
err := workflow.SetQueryHandler(ctx, "{{.Name}}", func() ({{.ResponseType}}, error) {
	// Return current state
	{{.Description}}
	return {{.ResponseType}}{}, nil
})
if err != nil {
	logger.Error("Failed to register query handler", "query", "{{.Name}}", "error", err)
}
`

const childWorkflowTemplate = `
// Execute child workflow {{.Name}}
childCtx := workflow.WithChildOptions(ctx, workflow.ChildWorkflowOptions{
	WorkflowID:  fmt.Sprintf("%s-child-%s", workflow.GetInfo(ctx).WorkflowExecution.ID, "{{.Name}}"),
	TaskQueue:   "{{.TaskQueue}}",
	RetryPolicy: &temporal.RetryPolicy{
		MaximumAttempts: 3,
	},
})

var childResult {{.OutputType}}
future := workflow.ExecuteChildWorkflow(childCtx, {{.Name}}Workflow, {{.InputType}}{})
if err := future.Get(childCtx, &childResult); err != nil {
	logger.Error("Child workflow failed", "workflow", "{{.Name}}", "error", err)
	return output, err
}
`